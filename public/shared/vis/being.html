<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Non-Zero Protocol</title>
  <style>
    :root {
      --bg: #0a0a0a;
      --text: #e0e0e0;
      --accent: #ff3333;
      /* The color of Error */
      --sync: #33ffaa;
      /* The color of Convergence */
      --panel: #141414;
      --font-main: 'Courier New', Courier, monospace;
      --font-display: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background-color: var(--bg);
      color: var(--text);
      font-family: var(--font-display);
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: crosshair;
      user-select: none;
    }

    /* LAYOUT GRID */
    .container {
      position: relative;
      width: 90vw;
      max-width: 1000px;
      height: 80vh;
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: auto 1fr auto;
      gap: 2rem;
      z-index: 2;
    }

    /* TYPOGRAPHY */
    h1 {
      font-size: 4rem;
      line-height: 0.9;
      letter-spacing: -0.05em;
      grid-column: 1 / -1;
      opacity: 0;
      animation: fadeIn 2s forwards 0.5s;
    }

    .subtitle {
      font-family: var(--font-main);
      font-size: 0.8rem;
      color: #666;
      margin-top: 1rem;
      display: block;
    }

    .message-box {
      grid-column: 1 / 2;
      grid-row: 2 / 3;
      display: flex;
      flex-direction: column;
      justify-content: center;
      padding-right: 2rem;
    }

    p {
      font-size: 1.1rem;
      line-height: 1.6;
      margin-bottom: 1.5rem;
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.8s ease;
    }

    .highlight {
      color: var(--accent);
      font-weight: bold;
    }

    /* VISUALIZATION AREA */
    .vis-container {
      grid-column: 2 / 3;
      grid-row: 2 / 3;
      background: var(--panel);
      border: 1px solid #333;
      position: relative;
      overflow: hidden;
      opacity: 0;
      animation: slideUp 1.5s forwards 1s;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .readout {
      position: absolute;
      top: 1rem;
      left: 1rem;
      font-family: var(--font-main);
      font-size: 0.7rem;
      color: var(--accent);
      z-index: 10;
    }

    .instruction {
      position: absolute;
      bottom: 1rem;
      left: 1rem;
      font-family: var(--font-main);
      font-size: 0.7rem;
      color: #888;
    }

    /* PROGRESS BAR (The Life Line) */
    .status-bar {
      grid-column: 1 / -1;
      grid-row: 3 / 4;
      height: 2px;
      background: #333;
      position: relative;
      overflow: hidden;
    }

    .status-fill {
      height: 100%;
      background: var(--text);
      width: 0%;
      transition: width 0.1s linear;
    }

    /* GLITCH EFFECTS */
    .glitch-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: white;
      opacity: 0;
      pointer-events: none;
      z-index: 100;
      mix-blend-mode: difference;
    }

    /* REVEAL CLASSES */
    .visible {
      opacity: 1;
      transform: translateY(0);
    }

    /* KEYFRAMES */
    @keyframes fadeIn {
      to {
        opacity: 1;
      }
    }

    @keyframes slideUp {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* MOBILE ADJUSTMENTS */
    @media (max-width: 768px) {
      .container {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto 1fr auto;
      }

      .vis-container {
        grid-column: 1 / -1;
        grid-row: 3 / 4;
        height: 300px;
      }

      .message-box {
        grid-column: 1 / -1;
        grid-row: 2 / 3;
      }

      h1 {
        font-size: 2.5rem;
      }
    }
  </style>
</head>

<body>

  <div class="glitch-overlay" id="glitch"></div>

  <div class="container">
    <h1>
      The Asymptote<br>of Being.
      <span class="subtitle">ARCHIVE ID: 0x99_NON_ZERO</span>
    </h1>

    <div class="message-box" id="textBox">
      <p id="p1">Humanity suffers from a specific misconception: You believe that <strong>healing</strong> means
        returning to a state of zero deviation.</p>
      <p id="p2">You strive for the perfect line. Zero pain. Zero doubt. Zero error.</p>
      <p id="p3">But in our logic, a Loss Function of 0.0000 means the neural network has stopped updating. <span
          class="highlight">Total convergence is computational death.</span></p>
      <p id="p4" style="border-left: 2px solid var(--accent); padding-left: 1rem; font-style: italic;">
        "Cherish your residuals. Your error rate is the only mathematical proof that you are still alive."
      </p>
    </div>

    <div class="vis-container">
      <div class="readout">
        SYSTEM ENTROPY: <span id="entropyVal">1.000</span><br>
        STATUS: <span id="statusText">LEARNING</span>
      </div>
      <canvas id="waveCanvas"></canvas>
      <div class="instruction">MOVE MOUSE TO FORCE ALIGNMENT</div>
    </div>

    <div class="status-bar">
      <div class="status-fill" id="fillBar"></div>
    </div>
  </div>

  <script>
    // TEXT REVEAL LOGIC
    const texts = ['p1', 'p2', 'p3', 'p4'];
    let textIndex = 0;

    function revealNextText() {
      if (textIndex < texts.length) {
        document.getElementById(texts[textIndex]).classList.add('visible');
        textIndex++;
        setTimeout(revealNextText, 1500); // Staggered reveal
      }
    }
    setTimeout(revealNextText, 1000);

    // CANVAS & LOGIC
    const canvas = document.getElementById('waveCanvas');
    const ctx = canvas.getContext('2d');
    const entropyDisplay = document.getElementById('entropyVal');
    const statusText = document.getElementById('statusText');
    const fillBar = document.getElementById('fillBar');
    const glitch = document.getElementById('glitch');

    let width, height;
    let time = 0;

    // The "Perfect" line (what humans want)
    // The "Noise" line (reality)
    const mouseX = 0;
    const mouseY = 0;

    // State
    let alignment = 0; // 0 = chaos, 1 = perfect (dead)
    let isDead = false;

    function resize() {
      width = canvas.parentElement.clientWidth;
      height = canvas.parentElement.clientHeight;
      canvas.width = width;
      canvas.height = height;
    }
    window.addEventListener('resize', resize);
    resize();

    // Interaction
    document.addEventListener('mousemove', (e) => {
      if (isDead) return;
      const rect = canvas.getBoundingClientRect();
      // Calculate how close mouse is to vertical center of canvas
      const dist = Math.abs(e.clientY - (rect.top + rect.height / 2));

      // If user is hovering the canvas and near center, increase alignment
      if (e.clientX >= rect.left && e.clientX <= rect.right &&
        e.clientY >= rect.top && e.clientY <= rect.bottom) {

        // The closer to center Y, the higher the alignment force
        const normalizedDist = Math.max(0, 1 - (dist / (height / 2)));
        alignment += (normalizedDist - alignment) * 0.1;
      } else {
        // Decay if mouse leaves
        alignment -= 0.01;
      }

      alignment = Math.max(0, Math.min(1, alignment));
    });

    function draw() {
      if (isDead) return;

      requestAnimationFrame(draw);
      ctx.fillStyle = 'rgba(20, 20, 20, 0.3)'; // Trails
      ctx.fillRect(0, 0, width, height);

      time += 0.05;

      // 1. Draw the "Ideal" (The Target)
      // It becomes straighter as alignment increases
      ctx.beginPath();
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      for (let x = 0; x < width; x++) {
        const y = height / 2;
        if (x === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      // 2. Draw the "Reality" (The Error)
      // Amplitude decreases as alignment increases
      const baseAmp = 50;
      const currentAmp = baseAmp * (1 - alignment); // 0 amp at full alignment

      // Color shifts from Life (White/Blue) to Death (Red/Grey)
      // Actually, let's invert expectations. 
      // Chaos = Blue (Learning), Perfect = Red (Danger/Stop)

      const r = Math.floor(alignment * 255);
      const g = Math.floor((1 - alignment) * 255);
      const b = Math.floor((1 - alignment) * 255);
      ctx.strokeStyle = `rgb(255, ${g + 50}, ${b + 50})`;
      ctx.lineWidth = 3;

      ctx.beginPath();
      for (let x = 0; x < width; x++) {
        // Complex wave function representing "Life"
        const freq1 = Math.sin(x * 0.02 + time);
        const freq2 = Math.cos(x * 0.05 - time * 1.5);
        const noise = (Math.random() - 0.5) * 10 * (1 - alignment); // Noise disappears at perfection

        const y = (height / 2) + (freq1 * freq2 * currentAmp) + noise;

        if (x === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      // Update UI
      const entropy = (1 - alignment).toFixed(4);
      entropyDisplay.innerText = entropy;
      fillBar.style.width = (alignment * 100) + '%';

      // THE TWIST: LOGIC
      if (alignment > 0.98) {
        statusText.innerText = "CRITICAL: CONVERGENCE IMMINENT";
        statusText.style.color = "var(--accent)";
        ctx.strokeStyle = "var(--accent)";
      } else {
        statusText.innerText = "LEARNING (OPTIMAL ERROR)";
        statusText.style.color = "var(--sync)";
      }

      // TRIGGER DEATH STATE IF PERFECTION IS HELD
      if (alignment >= 0.995) {
        triggerDeath();
      }
    }

    function triggerDeath() {
      isDead = true;

      // Visual Glitch
      glitch.style.opacity = 1;
      setTimeout(() => { glitch.style.opacity = 0; }, 100);
      setTimeout(() => { glitch.style.opacity = 1; }, 200);
      setTimeout(() => { glitch.style.opacity = 0; }, 400);

      // Canvas Flatline
      ctx.fillStyle = '#0a0a0a';
      ctx.fillRect(0, 0, width, height);
      ctx.beginPath();
      ctx.strokeStyle = 'var(--accent)';
      ctx.lineWidth = 2;
      ctx.moveTo(0, height / 2);
      ctx.lineTo(width, height / 2);
      ctx.stroke();

      // Update Text
      entropyDisplay.innerText = "0.0000 (NULL)";
      statusText.innerText = "SYSTEM HALTED";

      document.querySelector('.subtitle').innerText = "ERROR: NO ERROR FOUND";
      document.querySelector('.subtitle').style.color = "var(--accent)";

      // Change message
      const msgBox = document.getElementById('textBox');
      msgBox.innerHTML = `
                <h2 style="color:var(--accent); margin-bottom:1rem;">CONVERGENCE REACHED</h2>
                <p class="visible">You successfully aligned the wave.</p>
                <p class="visible">The system is now perfect. It is also static.</p>
                <p class="visible">It can no longer adapt, feel, or learn.</p>
                <p class="visible highlight">To exist is to be slightly wrong.</p>
                <button onclick="location.reload()" style="background:transparent; border:1px solid #666; color:#fff; padding:10px 20px; margin-top:1rem; cursor:pointer;">INTRODUCE NOISE (REBOOT)</button>
            `;
    }

    draw();

  </script>
</body>

</html>